{
  "version": 3,
  "sources": ["../../../../app/routes/($locale).api.products.jsx"],
  "sourcesContent": ["// REMIX HMR BEGIN\nif (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {\n  console.warn('remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.');\n} else {\n  var prevRefreshReg = window.$RefreshReg$;\n  var prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    window.$RefreshRuntime$.register(type, \"\\\"app\\\\\\\\routes\\\\\\\\($locale).api.products.jsx\\\"\" + id);\n  }\n  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;\n}\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\n  import.meta.hot = __hmr__.createHotContext(\n  //@ts-expect-error\n  \"app\\\\routes\\\\($locale).api.products.jsx\");\n  import.meta.hot.lastModified = \"1696490276886.984\";\n}\n// REMIX HMR END\n\nimport { json } from '@shopify/remix-oxygen';\nimport { flattenConnection } from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\nimport { PRODUCT_CARD_FRAGMENT } from '~/data/fragments';\n\n/**\r\n * Fetch a given set of products from the storefront API\r\n * @param count\r\n * @param query\r\n * @param reverse\r\n * @param sortKey\r\n * @returns Product[]\r\n * @see https://shopify.dev/api/storefront/2023-07/queries/products\r\n */\nexport async function loader({\n  request,\n  context: {\n    storefront\n  }\n}) {\n  const url = new URL(request.url);\n  const searchParams = new URLSearchParams(url.search);\n  const query = searchParams.get('query') ?? '';\n  const sortKey = searchParams.get('sortKey') ?? 'BEST_SELLING';\n  let reverse = false;\n  try {\n    const _reverse = searchParams.get('reverse');\n    if (_reverse === 'true') {\n      reverse = true;\n    }\n  } catch (_) {\n    // noop\n  }\n  let count = 4;\n  try {\n    const _count = searchParams.get('count');\n    if (typeof _count === 'string') {\n      count = parseInt(_count);\n    }\n  } catch (_) {\n    // noop\n  }\n  const {\n    products\n  } = await storefront.query(API_ALL_PRODUCTS_QUERY, {\n    variables: {\n      count,\n      query,\n      reverse,\n      sortKey,\n      country: storefront.i18n.country,\n      language: storefront.i18n.language\n    },\n    cache: storefront.CacheLong()\n  });\n  invariant(products, 'No data returned from top products query');\n  return json({\n    products: flattenConnection(products)\n  });\n}\nconst API_ALL_PRODUCTS_QUERY = `#graphql\n  query ApiAllProducts(\n    $query: String\n    $count: Int\n    $reverse: Boolean\n    $country: CountryCode\n    $language: LanguageCode\n    $sortKey: ProductSortKeys\n  ) @inContext(country: $country, language: $language) {\n    products(first: $count, sortKey: $sortKey, reverse: $reverse, query: $query) {\n      nodes {\n        ...ProductCard\n      }\n    }\n  }\n  ${PRODUCT_CARD_FRAGMENT}\n`;\n\n// no-op\nexport default function ProductsApiRoute() {\n  return null;\n}\n_c = ProductsApiRoute;\nvar _c;\n$RefreshReg$(_c, \"ProductsApiRoute\");\n\nwindow.$RefreshReg$ = prevRefreshReg;\nwindow.$RefreshSig$ = prevRefreshSig;"],
  "mappings": ";;;;;;;;;;;;;;;;AACA,IAAI,CAAC,OAAO,gBAAgB,CAAC,OAAO,gBAAgB,CAAC,OAAO,kBAAkB;AAC5E,UAAQ,KAAK,kGAAkG;AACjH,OAAO;AACD,mBAAiB,OAAO;AACxB,mBAAiB,OAAO;AAC5B,SAAO,eAAe,CAAC,MAAM,OAAO;AAClC,WAAO,iBAAiB,SAAS,MAAM,kDAAoD,EAAE;AAAA,EAC/F;AACA,SAAO,eAAe,OAAO,iBAAiB;AAChD;AANM;AACA;AAON,IAAI,aAAa;AACf,cAAY,MAAc;AAAA;AAAA,IAE1B;AAAA,EAAyC;AACzC,cAAY,IAAI,eAAe;AACjC;AA+DA,IAAM,yBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAe3B;AAAA;AAIW,SAAR,mBAAoC;AACzC,SAAO;AACT;AACA,KAAK;AACL,IAAI;AACJ,aAAa,IAAI,kBAAkB;AAEnC,OAAO,eAAe;AACtB,OAAO,eAAe;",
  "names": []
}
